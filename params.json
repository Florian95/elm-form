{"name":"Elm Simple Form","tagline":"Easy forms handling in Elm","body":"# Elm SimpleForm\r\n\r\nSimple forms made easy, for Elm.\r\n\r\n_Work in progress_\r\n\r\n## Features\r\n\r\n* Validation API similar to `Json.Decode` with the standard `map`, `andThen`, etc ; you either get the desired output value or all field errors\r\n* HTML inputs helpers with pre-wired handlers for live validation\r\n* Suite of basic validations, with a way to add your own\r\n* Unlimited fields! See `:+` infix operator (or `apply` function)\r\n* Nested fields for record composition (`foo.bar.baz`)\r\n\r\n[See complete example here.](./example/)\r\n\r\n\r\n## Basic usage\r\n\r\n```elm\r\nmodule Main where\r\n\r\nimport StartApp\r\nimport Effects exposing (Effects)\r\nimport Html exposing (..)\r\nimport Html.Attributes exposing (..)\r\nimport Html.Events exposing (..)\r\n\r\nimport Form exposing (Form)\r\nimport Form.Validate as Validate exposing (..)\r\nimport Form.Input as Input\r\n\r\n\r\ntype alias Foo =\r\n  { bar : String\r\n  , baz : Bool\r\n  }\r\n\r\n\r\n-- Add form to your model and actions\r\n\r\ntype alias Model =\r\n  { form : Form () Foo }\r\n\r\ntype Action\r\n  = NoOp\r\n  | FormAction Form.Action\r\n\r\n\r\n-- Setup form validation\r\n\r\ninit : (Model, Effects Action)\r\ninit =\r\n  ({ form = Form.initial [] validate }, Effects.none)\r\n\r\nvalidate : Validate () Form\r\nvalidate =\r\n  form2 Foo\r\n    (\"bar\" := email)\r\n    (\"baz\" := bool)\r\n    \r\n\r\n-- Forward form actions to Form.update\r\n\r\nupdate : Action -> Model -> (Model, Effects Action)\r\nupdate action ({form} as model) =\r\n  case action of\r\n\r\n    NoOp ->\r\n      (model, Effects.none)\r\n\r\n    FormAction formAction ->\r\n      ({ model | form = Form.update formAction form}, Effects.none)\r\n\r\n\r\n-- Render form with Input helpers\r\n\r\nview : Signal.Address Action -> Model -> Html\r\nview address {form} =\r\n  let\r\n    -- Address for Form events\r\n    formAddress = Signal.forwardTo address FormAction\r\n\r\n    -- error presenter\r\n    errorFor field =\r\n      case field.liveError of\r\n        Just error ->\r\n          -- replace toString with your own translations\r\n          div [ class \"error\" ] [ text (toString error) ] \r\n        Nothing ->\r\n          text \"\"\r\n          \r\n    -- fields states\r\n    bar = Form.getFieldAsString \"bar\" form\r\n    baz = Form.getFieldAsBool \"baz\" form\r\n  in\r\n    div []\r\n      [ label [] [ text \"Bar\" ]\r\n      , Input.textInput bar formAddress []\r\n      , errorFor bar\r\n      \r\n      , label [] \r\n      , Input.checkboxInput baz formAddress []\r\n      , text \"Baz\"\r\n      ]\r\n\r\n      , errorFor baz\r\n      \r\n      , button\r\n          [ onClick formAddress Form.submit ]\r\n          [ text \"Submit\" ]\r\n      ]\r\n\r\n\r\n-- Classic StartApp wiring\r\n\r\napp = StartApp.start\r\n  { init = init\r\n  , update = update\r\n  , view = view\r\n  , inputs = [ ]\r\n  }\r\n\r\nmain =\r\n  app.html\r\n\r\nport tasks : Signal (Task Effects.Never ())\r\nport tasks =\r\n  app.tasks\r\n```\r\n\r\n\r\n## Advanced usage\r\n\r\n### Incremental validation\r\n\r\nSimilar to what Json.Extra provides. Use `Form.apply`, or the `|:` infix version:\r\n\r\n```elm\r\nForm.succeed Player\r\n  |: (\"email\" := string `andThen` email)\r\n  |: (\"power\" := int)\r\n```\r\n\r\n### Nested records\r\n\r\n* Validation:\r\n\r\n```elm\r\nvalidate =\r\n  form2 Player\r\n    (\"email\" := string `andThen` email)\r\n    (\"power\" := int `andThen` (minInt 0))\r\n    (\"options\" := form2 Options\r\n      (\"foo\" := string)\r\n      (\"bar\" := string))\r\n```\r\n\r\n* View:\r\n\r\n```elm\r\nInput.textInput (Form.getFieldAsString \"options.foo\" form) formAddress []\r\n```\r\n\r\n### Initial values and reset\r\n\r\n* At form initialization:\r\n\r\n```elm\r\nimport Form.Field as Field\r\n\r\ninitialFields : List (String, Field)\r\ninitialFields =\r\n  [ (\"power\", Field.text \"10\")\r\n  , (\"options\", Field.group\r\n      [ (\"foo\", Field.text \"blah\")\r\n      , (\"bar\", Field.text \"meh\")\r\n      ]\r\n    )\r\n  ]\r\n\r\ninitialForm : Form\r\ninitialForm =\r\n  Form.initial initialFields validate\r\n```\r\n\r\nSee `Form.Field` functions for more options.\r\n\r\n* On demand:\r\n\r\n```elm\r\nbutton [ onClick formAddress (Form.reset initialFields) ] [ text \"Reset\" ]\r\n```\r\n\r\n\r\n### Custom errors\r\n\r\n```elm\r\ntype LocalError = Fatal | NotSoBad\r\n\r\nvalidate : Validate LocalError Foo\r\nvalidate =\r\n  (\"foo\" := string |> customError Fatal)\r\n\r\n-- creates `Form.Error.CustomError Fatal`\r\n```\r\n\r\n\r\n### Async validation\r\n\r\nThis package doesn't provide anything special for async validation, but doesn't prevent you to do that neither. As field values are accessible from `update` with `Form.getStringAt/getBoolAt`, you can proceed them as you need, trigger effects like an HTTP request, and then add any errors to the view by yourself.\r\n\r\nAnother way would be to enable dynamic validation reload, to make it dependant of an effect, as it's part of the form state. Please ping me if this feature would be useful to you.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}